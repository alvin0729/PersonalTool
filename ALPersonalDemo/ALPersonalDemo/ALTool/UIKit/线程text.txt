线程：
TableView中实现平滑滚动延迟加载图片


[self.avatarImageView performSelector:@selector(setImage:)
withObject:downloadedImage
afterDelay:0
inModes:@[NSDefaultRunLoopMode]];

AFNetworking
单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
@autoreleasepool {
[[NSThread currentThread] setName:@"AFNetworking"];

NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
[runLoop run];
}
}

+ (NSThread *)networkRequestThread {
static NSThread *_networkRequestThread = nil;
static dispatch_once_t oncePredicate;
dispatch_once(&oncePredicate, ^{
_networkRequestThread =
[[NSThread alloc] initWithTarget:self
selector:@selector(networkRequestThreadEntryPoint:)
object:nil];
[_networkRequestThread start];
});

return _networkRequestThread;
}
类似的可以用这个方法创建一个常驻服务的线程。


异步测试
- (BOOL)runUntilBlock:(BOOL(^)())block timeout:(NSTimeInterval)timeout
{
__block Boolean fulfilled = NO;
void (^beforeWaiting) (CFRunLoopObserverRef observer, CFRunLoopActivity activity) =
^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
fulfilled = block();
if (fulfilled) {
CFRunLoopStop(CFRunLoopGetCurrent());
}
};

CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopBeforeWaiting, true, 0, beforeWaiting);
CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);

// Run!
CFRunLoopRunInMode(kCFRunLoopDefaultMode, timeout, false);

CFRunLoopRemoveObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);
CFRelease(observer);

return fulfilled;
}


NSRunLoop的运行接口：
//运行 NSRunLoop，运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制
- (void)run;
//运行 NSRunLoop: 参数为运时间期限，运行模式为默认的NSDefaultRunLoopMode模式
- (void)runUntilDate:(NSDate *)limitDate;
//运行 NSRunLoop: 参数为运行模式、时间期限，返回值为YES表示是处理事件后返回的，NO表示是超时或者停止运行导致返回的
- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;
CFRunLoopRef的运行接口：
//运行 CFRunLoopRef
void CFRunLoopRun();
//运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因
SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);
//停止运行 CFRunLoopRef
void CFRunLoopStop( CFRunLoopRef rl );
//唤醒CFRunLoopRef
void CFRunLoopWakeUp ( CFRunLoopRef rl );

runloop运行方法一共5种：包括NSRunloop的3种，CFRunloop的两种;
而取消的方式一共为3种：
1）移除掉runloop中的所有事件源（timer和source）。
2）设置一个超时时间。
3）只要CFRunloop运行起来就可以用：void CFRunLoopStop( CFRunLoopRef rl );去停止。
除此之外用NSRunLoop下面这个方法运行也能使用void CFRunLoopStop( CFRunLoopRef rl );停止：
[NSRunLoop currentRunLoop]runMode:<#(nonnull NSRunLoopMode)#> beforeDate:<#(nonnull NSDate *)#>
实际过程中，可以根据需求，我们可以设置一个自己的Bool值，来控制runloop的开始与停止,类似下面这样：
while (!cancel) {
CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1, YES);
}
每次runloop只运行1秒就停止，然后开始下一次的runloop。
这里最后一个参数设置为YES，当有非timer事件进来，也会立即开始下一次runloop。
当然每次进来我们都可以去修改Mode的值，这样我们可以让runloop每次都运行在不同的模式下。
当我们不需要runloop的时候，直接将cancel置为YES即可。


