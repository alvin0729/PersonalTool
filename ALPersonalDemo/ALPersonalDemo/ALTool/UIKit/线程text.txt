
http://aaaboom.com/?p=37
线程：
TableView中实现平滑滚动延迟加载图片


[self.avatarImageView performSelector:@selector(setImage:)
withObject:downloadedImage
afterDelay:0
inModes:@[NSDefaultRunLoopMode]];

AFNetworking
单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
@autoreleasepool {
[[NSThread currentThread] setName:@"AFNetworking"];

NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
[runLoop run];
}
}

+ (NSThread *)networkRequestThread {
static NSThread *_networkRequestThread = nil;
static dispatch_once_t oncePredicate;
dispatch_once(&oncePredicate, ^{
_networkRequestThread =
[[NSThread alloc] initWithTarget:self
selector:@selector(networkRequestThreadEntryPoint:)
object:nil];
[_networkRequestThread start];
});

return _networkRequestThread;
}
类似的可以用这个方法创建一个常驻服务的线程。


异步测试
- (BOOL)runUntilBlock:(BOOL(^)())block timeout:(NSTimeInterval)timeout
{
__block Boolean fulfilled = NO;
void (^beforeWaiting) (CFRunLoopObserverRef observer, CFRunLoopActivity activity) =
^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
fulfilled = block();
if (fulfilled) {
CFRunLoopStop(CFRunLoopGetCurrent());
}
};

CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopBeforeWaiting, true, 0, beforeWaiting);
CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);

// Run!
CFRunLoopRunInMode(kCFRunLoopDefaultMode, timeout, false);

CFRunLoopRemoveObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);
CFRelease(observer);

return fulfilled;
}


NSRunLoop的运行接口：
//运行 NSRunLoop，运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制
- (void)run;
//运行 NSRunLoop: 参数为运时间期限，运行模式为默认的NSDefaultRunLoopMode模式
- (void)runUntilDate:(NSDate *)limitDate;
//运行 NSRunLoop: 参数为运行模式、时间期限，返回值为YES表示是处理事件后返回的，NO表示是超时或者停止运行导致返回的
- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;
CFRunLoopRef的运行接口：
//运行 CFRunLoopRef
void CFRunLoopRun();
//运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因
SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);
//停止运行 CFRunLoopRef
void CFRunLoopStop( CFRunLoopRef rl );
//唤醒CFRunLoopRef
void CFRunLoopWakeUp ( CFRunLoopRef rl );

runloop运行方法一共5种：包括NSRunloop的3种，CFRunloop的两种;
而取消的方式一共为3种：
1）移除掉runloop中的所有事件源（timer和source）。
2）设置一个超时时间。
3）只要CFRunloop运行起来就可以用：void CFRunLoopStop( CFRunLoopRef rl );去停止。
除此之外用NSRunLoop下面这个方法运行也能使用void CFRunLoopStop( CFRunLoopRef rl );停止：
[NSRunLoop currentRunLoop]runMode:<#(nonnull NSRunLoopMode)#> beforeDate:<#(nonnull NSDate *)#>
实际过程中，可以根据需求，我们可以设置一个自己的Bool值，来控制runloop的开始与停止,类似下面这样：
while (!cancel) {
CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1, YES);
}
每次runloop只运行1秒就停止，然后开始下一次的runloop。
这里最后一个参数设置为YES，当有非timer事件进来，也会立即开始下一次runloop。
当然每次进来我们都可以去修改Mode的值，这样我们可以让runloop每次都运行在不同的模式下。
当我们不需要runloop的时候，直接将cancel置为YES即可。


- (void)clearImagesCache {
// 放在了非公开的扩展中，但是方法是存在的
if ([[UIApplication sharedApplication] respondsToSelector:NSSelectorFromString(@"hyb_clearDiskCaches")]) {
((void (*)(id, SEL))objc_msgSend)([UIApplication sharedApplication],
NSSelectorFromString(@"hyb_clearDiskCaches"));
}
}

使用注意1：使用objc_msgSend crash解决方案
Enable Strict Checking of objc_msgSend Calls -> NO
使用注意2：objc_msgSend arm64 崩溃问题
- (void) doSomethingElse {
int (*action)(id, SEL, int) = (int (*)(id, SEL, int)) objc_msgSend;
action(self, @selector(doSomething:), 0);
}
###########
void (*glt_msgsend)(id, SEL, NSString *, NSString *) = (void (*)(id, SEL, NSString *, NSString *))objc_msgSend;
glt_msgsend(cls, @selector(eat:say:), @"123", @"456");
###########
TestClass *cls = [[TestClass alloc] init];
objc_msgSend(cls, @selector(fun)); //错误写法(arm64崩溃偶尔发生)
((void (*)(id, SEL))objc_msgSend)(cls, @selector(fun)); //正确写法
###########
方案一：(需测试)

以下是对NSObject类的扩展方法：
NS_REQUIRES_NIL_TERMINATION：是对多参数传递值得一个宏
va_list args：定义一个指向个数可变的参数列表指针；
va_start(args,object)：object为第一个参数，也就是最右边的已知参数,这里就是获取第一个可选参数的地址.使参数列表指针指向函数参数列表中的第一个可选参数，函数参数列表中参数在内存中的顺序与函数声明时的顺序是一致的。
va_arg(args,id)：返回参数列表中指针所指的参数，返回类型为id，并使参数指针指向参数列表中下一个参数。
va_end(args)：清空参数列表，并置参数指针args无效。
其他说明见代码注释
[objc] view plain copy
-(id)glt_performSelector:(SEL)selector withObject:(id)object,...NS_REQUIRES_NIL_TERMINATION;
{
//根据类名以及SEL 获取方法签名的实例
NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:selector];
if (signature == nil) {
NSLog(@"--- 使用实例方法调用 为nil ---");
signature = [self methodSignatureForSelector:selector];
if (signature == nil) {
NSLog(@"使用类方法调用 也为nil， 此时return");
return nil;
}
}
//NSInvocation是一个消息调用类，它包含了所有OC消息的成分：target、selector、参数以及返回值。
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
invocation.target = self;
invocation.selector = selector;
NSUInteger argCount = signature.numberOfArguments;
// 参数必须从第2个索引开始，因为前两个已经被target和selector使用
argCount = argCount > 2 ? argCount - 2 : 0;
NSMutableArray *objs = [NSMutableArray arrayWithCapacity:0];
if (object) {
[objs addObject:object];
va_list args;
va_start(args, object);
while ((object = va_arg(args, id))){
[objs addObject:object];
}
va_end(args);
}
if (objs.count != argCount){
NSLog(@"--- objs.count != argCount! please check it! ---");
return nil;
}
//设置参数列表
for (NSInteger i = 0; i < objs.count; i++) {
id obj = objs[i];
if ([obj isKindOfClass:[NSNull class]]) {
continue;
}
[invocation setArgument:&obj atIndex:i+2];
}
[invocation invoke];
//获取返回值
id returnValue = nil;
if (signature.methodReturnLength != 0 && signature.methodReturnLength) {
[invocation getReturnValue:&signature];
}
return returnValue;
}
###########

https://www.jianshu.com/p/177e44a411db








